package com.JEEproject.Backend.Controllers;

import com.JEEproject.Backend.DTOs.MissionDto;
import com.JEEproject.Backend.DTOs.OrderDto;
import com.JEEproject.Backend.Enums.Cities;
import com.JEEproject.Backend.Enums.MissionType;
import com.JEEproject.Backend.Enums.OrderType;
import com.JEEproject.Backend.Enums.TrackingStatus;
import com.JEEproject.Backend.Models.Driver;
import com.JEEproject.Backend.Models.Mission;
import com.JEEproject.Backend.Models.Order;
import com.JEEproject.Backend.Repositories.DriverRepository;
import com.JEEproject.Backend.Repositories.MissionRepository;
import com.JEEproject.Backend.Repositories.OrderRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/missions")
public class MissionController {
    private final OrderRepository orderRepo;
    private final MissionRepository missionRepo;
    private final DriverRepository driverRepo;

    @Autowired
    public MissionController(OrderRepository orderRepo, MissionRepository missionRepo, DriverRepository driverRepo) {
        this.orderRepo = orderRepo;
        this.missionRepo = missionRepo;
        this.driverRepo = driverRepo;
    }

    // Method to calculate and update the priority of a single order
    public void calculateAndUpdatePriority(Order order) {
        // Determine index based on order type
        int index = (order.getOrderType() == OrderType.Express) ? 3 : 1;
        int status = (order.getTracking_status() == TrackingStatus.CollectingFromSender || order.getTracking_status() == TrackingStatus.InCollectingAgency) ? 2 : 1;

        // Calculate the time difference in minutes between the current date and the order's creation date
        Instant creationInstant = order.getDate().toInstant();
        Instant currentInstant = new Date().toInstant();
        long minutesDifference = Duration.between(creationInstant, currentInstant).toMinutes();

        // Calculate priority based on the formula
        int priority = (int) (2 * minutesDifference * index * status);

        // Update and save the order with the new priority
        order.setPriority(priority);
        orderRepo.save(order);
    }

    // Endpoint to update priorities of orders in a specific city
    @PutMapping("/updatePrioritiesByCity/{city}")
    public ResponseEntity<String> updatePrioritiesByCity(@PathVariable Cities city) {
        try {
            // Fetch all orders matching the tracking status and city conditions
            List<Order> orders = orderRepo.findLocalOrders(
                    TrackingStatus.CollectingFromSender,
                    TrackingStatus.DeliveringToReceiver,
                    city
            );

            // Update each order's priority
            for (Order order : orders) {
                calculateAndUpdatePriority(order); // Call the method with the order instance
            }

            return new ResponseEntity<>("Priorities updated successfully for selected orders in " + city, HttpStatus.OK);
        } catch (Exception e) {
            return new ResponseEntity<>("Failed to update priorities: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @PostMapping("/createMission/{city}/{driverId}")
    public ResponseEntity<String> createMission(@PathVariable Cities city, @PathVariable int driverId) {
        updatePrioritiesByCity(city);
        try {
            // Fetch orders based on tracking statuses, city, and priority
            List<Order> orders = orderRepo.findLocalOrders(
                    TrackingStatus.CollectingFromSender, TrackingStatus.DeliveringToReceiver, city
            );

            // Sort orders by priority descending
            orders.sort(Comparator.comparingInt(Order::getPriority).reversed());

            List<Order> selectedOrders = new ArrayList<>();
            int totalWeight = 0;

            // Select orders until the total weight limit of 100 kg is reached
            for (Order order : orders) {
                if (totalWeight + order.getWeight() <= 100) {
                    selectedOrders.add(order);
                    totalWeight += order.getWeight();
                } else {
                    break;
                }
            }

            Driver driver = driverRepo.findById(driverId).orElseThrow(() -> new RuntimeException("Driver not found"));
            // Create the new mission
            Mission mission = new Mission(
                    0, // ID will be generated by the database
                    false,
                    MissionType.In_City,
                    new Date(),
                    null,
                    city,
                    selectedOrders.get(0).getReceiver().getCity(),
                    driver, // ensure driver is fetched from the database
                    selectedOrders
            );

            // Save the mission to the database
            missionRepo.save(mission);

            return new ResponseEntity<>("Mission created successfully with " + selectedOrders.size() + " orders.", HttpStatus.CREATED);
        } catch (Exception e) {
            return new ResponseEntity<>("Failed to create mission: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    // Endpoint to update priorities of foreign orders
    @PutMapping("/updateForeignPriorities/{cityFrom}/{cityTo}")
    public ResponseEntity<String> updateForeignPriorities(@PathVariable Cities cityFrom, @PathVariable Cities cityTo) {
        if (cityFrom == cityTo) {
            return new ResponseEntity<>("Error: From city cannot be the same as to city.", HttpStatus.BAD_REQUEST);
        }
        try {
            List<Order> orders = orderRepo.findForeignOrders(cityFrom, cityTo);

            for (Order order : orders) {
                calculateAndUpdatePriority(order);
            }

            return new ResponseEntity<>("Priorities updated successfully for selected foreign orders from " + cityFrom + " to " + cityTo, HttpStatus.OK);
        } catch (Exception e) {
            return new ResponseEntity<>("Failed to update foreign priorities: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @PostMapping("/createForeignMission/{cityFrom}/{cityTo}/{driverId}")
    public ResponseEntity<String> createForeignMission(@PathVariable Cities cityFrom, @PathVariable Cities cityTo, @PathVariable int driverId) {
        if (cityFrom == cityTo) {
            return new ResponseEntity<>("Error: From city cannot be the same as to city.", HttpStatus.BAD_REQUEST);
        }
        updateForeignPriorities(cityFrom, cityTo);
        try {
            List<Order> orders = orderRepo.findForeignOrders(cityFrom, cityTo);

            orders.sort(Comparator.comparingInt(Order::getPriority).reversed());

            List<Order> selectedOrders = new ArrayList<>();
            int totalWeight = 0;

            for (Order order : orders) {
                if (totalWeight + order.getWeight() <= 3000) {
                    selectedOrders.add(order);
                    totalWeight += order.getWeight();
                } else {
                    break;
                }
            }

            Driver driver = driverRepo.findById(driverId).orElseThrow(() -> new RuntimeException("Driver not found"));
            Mission mission = new Mission(
                    0,
                    false,
                    MissionType.Inter_agency, // Change mission type to Foreign
                    new Date(),
                    null,
                    cityFrom,
                    cityTo,
                    driver,
                    selectedOrders
            );

            missionRepo.save(mission);

            return new ResponseEntity<>("Foreign mission created successfully with " + selectedOrders.size() + " orders.", HttpStatus.CREATED);
        } catch (Exception e) {
            return new ResponseEntity<>("Failed to create foreign mission: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @Transactional
    @GetMapping("/driver/{driverId}")
    public ResponseEntity<List<MissionDto>> getMissionsByDriverId(@PathVariable int driverId) {
        try {
            Driver driver = driverRepo.findById(driverId)
                    .orElseThrow(() -> new RuntimeException("Driver not found"));

            List<Mission> missions = missionRepo.findByDriver(driver);

            if (missions.isEmpty()) {
                return new ResponseEntity<>(HttpStatus.NO_CONTENT);
            }

            List<MissionDto> missionDtos = missions.stream().map(mission -> {
                MissionDto missionDto = new MissionDto(
                        mission.getId_mission(),
                        mission.getIs_done(),
                        mission.getMission_type(),
                        mission.getStart_date(),
                        mission.getEnd_date(),
                        mission.getFrom_city(),
                        mission.getTo_city()
                );

                // Convertir les commandes associées à chaque mission en objets OrderDto
                List<OrderDto> orderDtos = mission.getOrders().stream().map(order -> new OrderDto(
                        order.getIdOrder(),
                        order.getDate(),
                        order.getTracking_status(),
                        order.getOrderType(),
                        order.getPrice(),
                        order.getPriority(),
                        order.getWeight(),
                        order.getClient().getId_user(),
                        order.getReceiver().getId_receiver(),
                        order.getIs_aborted(),
                        order.getClient().getCompany(),
                        order.getReceiver().getFullname(),
                        order.getClient().getAgency().getCity(),
                        order.getReceiver().getCity(),
                        order.getClient().getAddress(),
                        order.getReceiver().getAddress()
                )).collect(Collectors.toList());

                // Ajouter les OrderDto au MissionDto
                missionDto.setOrders(orderDtos);

                return missionDto;
            }).collect(Collectors.toList());

            return new ResponseEntity<>(missionDtos, HttpStatus.OK);
        } catch (Exception e) {
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @PutMapping("/updateTrackingStatus/{driverId}/{orderId}")
    public ResponseEntity<String> updateTrackingStatus(
            @PathVariable int driverId,
            @PathVariable int orderId,
            @RequestParam TrackingStatus newStatus
    ) {
        try {
            // Vérification que le chauffeur existe
            Driver driver = driverRepo.findById(driverId)
                    .orElseThrow(() -> new RuntimeException("Driver not found"));

            // Récupération de la commande
            Order order = orderRepo.findById(orderId)
                    .orElseThrow(() -> new RuntimeException("Order not found"));

            // Vérifier si l'ordre est associé à une mission dans mission_details
            List<Mission> missions = order.getMissions().stream()
                    .filter(mission -> mission.getDriver().getId_user() == driverId)
                    .collect(Collectors.toList());

            if (missions.isEmpty()) {
                return new ResponseEntity<>("Order is not associated with any mission for this driver.", HttpStatus.BAD_REQUEST);
            }

            // Utiliser la première mission associée si plusieurs existent
            Mission mission = missions.get(0);

            // Vérification si la mission appartient au chauffeur
            if (mission.getDriver().getId_user() != driverId) {
                return new ResponseEntity<>("Unauthorized: Mission does not belong to the driver", HttpStatus.UNAUTHORIZED);
            }

            // Mise à jour du statut de suivi de l'ordre
            order.setTracking_status(newStatus);
            orderRepo.save(order);

            // Vérifier si le nouveau statut est "Delivered"
            if (newStatus == TrackingStatus.Delivered) {
                // Vérifier si tous les ordres de la mission sont "Delivered"
                boolean allOrdersDelivered = mission.getOrders().stream()
                        .allMatch(o -> o.getTracking_status() == TrackingStatus.Delivered);

                if (allOrdersDelivered) {
                    // Mettre à jour la mission comme terminée
                    mission.setIs_done(true);
                    missionRepo.save(mission);
                }
            }

            return new ResponseEntity<>("Tracking status updated successfully to " + newStatus, HttpStatus.OK);
        } catch (Exception e) {
            return new ResponseEntity<>("Failed to update tracking status: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }


}